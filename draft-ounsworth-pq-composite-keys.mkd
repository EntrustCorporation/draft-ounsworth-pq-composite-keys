---
title: Composite Public and Private Keys For Use In Internet PKI
abbrev: PQ Composite Keys
# <!-- EDNOTE: Edits the draft name -->
docname: draft-ounsworth-pq-composite-keys-04

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
stream: IETF
wg: LAMPS
kw: Internet-Draft
cat: std
venue:
  group: "Limited Additional Mechanisms for PKIX and SMIME (lamps)"
  type: "Working Group"
  mail: "spasm@ietf.org"
  arch: "https://mailarchive.ietf.org/arch/browse/spasm/"
  github: "EntrustCorporation/draft-ounsworth-pq-composite-keys"

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road – Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: mike.ounsworth@entrust.com

    -
      ins: J. Gray
      name: John GRay
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road – Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: john.gray@entrust.com

    -
      ins: M. Pala
      name: Massimiliano Pala
      org: CableLabs
      email: director@openca.org

    -
      ins: J. Klaussner
      name: Jan Klaussner
      org: D-Trust GmbH
      email: jan.klaussner@d-trust.net
      street: Kommandantenstr. 15
      code: 10969
      city: Berlin
      country: Germany

normative:
  RFC1421:
  RFC2119:
  RFC2986:
  RFC5280:
  RFC5480:
  RFC5639:
  RFC5652:
  RFC5912:
  RFC5914:
  RFC5915:
  RFC5958:
  RFC6090:
  RFC7468:
  RFC7748:
  RFC8017:
  RFC8174:
  RFC8410:
  RFC8411:
  I-D.draft-ounsworth-pq-composite-sigs-05:
  I-D.draft-ounsworth-pq-composite-kem-00:
  I-D.draft-ietf-lamps-dilithium-certificates-00:
  I-D.draft-ietf-lamps-cms-sphincs-plus-01:
  I-D.draft-ietf-lamps-kyber-certificates-00:
  X.690:
      title: "Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"
      date: November 2015
      author:
        org: ITU-T
      seriesinfo:
        ISO/IEC: 8825-1:2015


# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  RFC3279:
  RFC4210:
  RFC4211:
  RFC7292:
  RFC7296:
  RFC8446:
  RFC8551:
  I-D.draft-becker-guthrie-noncomposite-hybrid-auth-00:
  I-D.draft-guthrie-ipsecme-ikev2-hybrid-auth-00:
  I-D.draft-driscoll-pqt-hybrid-terminology-01:
  Bindel2017:
    title: "Transitioning to a quantum-resistant public key infrastructure"
    target: "https://link.springer.com/chapter/10.1007/978-3-319-59879-6_22"
    author:
      -
        ins: N. Bindel
        name: Nina Bindel
      -
        ins: U. Herath
        name: Udyani Herath
      -
        ins: M. McKague
        name: Matthew McKague
      -
        ins: D. Stebila
        name: Douglas Stebila
    date: 2017
  codeSigningBRsv2.8:
    title: "Baseline Requirements for the Issuance and Management of Publicly-Trusted Code Signing Certificates v2.8"
    target: https://cabforum.org/wp-content/uploads/Baseline-Requirements-for-the-Issuance-and-Management-of-Code-Signing.v2.8.pdf
    author:
      -
        ins: CAB Forum
        name: CA / Browser Forum
    date: May 9, 2022
  eIDAS2014:
    title: "REGULATION (EU) No 910/2014 OF THE EUROPEAN PARLIAMENT AND OF THE COUNCIL of 23 July 2014 on electronic identification and trust services for electronic transactions in the internal market and repealing Directive 1999/93/EC"
    target: https://ec.europa.eu/futurium/en/system/files/ged/eidas_regulation.pdf
    Author:
      -
        ins: European Council
        name: THE EUROPEAN PARLIAMENT AND THE COUNCIL OF THE EUROPEAN UNION,
    date: 23 July 2014
  Bleichenbacher1998:
    title: "Chosen ciphertext attacks against protocols based on the RSA encryption standard PKCS# 1."
    author:
      -
        ins: D. Bleichenbacher
        name: Daniel Bleichenbacher 
    date: 1998
  ROBOT2018:
    title: "Return Of {Bleichenbacher’s} Oracle Threat (ROBOT)."
    target: "https://www.usenix.org/conference/usenixsecurity18/presentation/bock"
    author:
      - 
        ins: H. Böck 
        name: Böck, Hanno
      - 
        ins: J. Somorovsky
        name: Juraj Somorovsky
      -
        ins: C. Young
        name: Craig Young.  
    date: 2018
  Mosca2015:
    title: "Cybersecurity in a Quantum World: will we be ready?"
    target: "https://csrc.nist.gov/csrc/media/events/workshop-on-cybersecurity-in-a-post-quantum-world/documents/presentations/session8-mosca-michele.pdf"
    author:
      -
        ins: M. Mosca
        name: Michele Mosca
    date: "3 April 2015"
  Beullens2022:
    title: "Breaking rainbow takes a weekend on a laptop."
    target: "https://eprint.iacr.org/2022/214"
    author:
      -
        ins: W. Beullens
        name: Ward Beullens
    date: 2022
  Castryck2022:
    title: "An efficient key recovery attack on SIDH (preliminary version)."
    target: "https://eprint.iacr.org/2022/975.pdf"
    author:
      - 
        ins: W. Castryck
        name: Wouter Castryck
      - 
        ins: T. Decru
        name: Thomas Decru
    date: 2022



--- abstract

The migration to post-quantum cryptography is unique in the history of modern digital cryptography in that neither the old outgoing nor the new incoming algorithms are fully trusted to protect data for the required data lifetimes. The outgoing algorithms, such as RSA and elliptic curve, may fall to quantum cryptalanysis, while the incoming post-quantum algorithms face uncertainty about both the underlying mathematics as well as hardware and software implementations that have not had sufficient maturing time to rule out classical cryptanalytic attacks and implementation bugs.

Cautious implementers may wish to layer cryptographic algorithms such that an attacker would need to break all of them in order to compromise the data being protected using either a Post-Quantum / Traditional Hybrid, Post-Quantum / Post-Quantum Hybrid, or combinations thereof. This document, and its companions, defines a specific instantiation of hybrid paradigm called "composite" where multiple cryptographic algorithms are combined to form a single key, signature, or key encapsulation mechanism (KEM) such that they can be treated as a single atomic object at the protocol level.

This document defines the structures CompositePublicKey and CompositePrivateKey, which are sequences of the respective structure for each component algorithm. The generic composite variant is defined which allows arbitrary combinations of key types to be placed in the CompositePublicKey and CompositePrivateKey structures without needing the combination to be pre-registered or pre-agreed. The explicit variant is alxso defined which allows for a set of algorithm identifier OIDs to be registered together as an explicit composite algorithm and assigned an OID.

This document is intended to be coupled with corresponding documents that define the structure and semantics of composite signatures and encryption, such as {{I-D.ounsworth-pq-composite-sigs}} and {{I-D.ounsworth-pq-composite-kem}}.

<!-- End of Abstract -->

--- middle

# Changes in version -04

- General restructuring of the document.
- Aligned composite pairings with OpenPGP and JOSE/COSE WGs TODO: INSERT DRAFT REF
- We have dropped the MAY / RECOMMENDED column as well as per-algorithm usage guidance because in the end we think it does not belong at the X.509 level because we believe these recommendations belong at the application profile level; for example what is RECOMMENDED for X.509-based client authentication may be very different from what is RECOMMENDED for X.509-based code-signing.
- Renamed "id-SPHINCSsha256256frobust-ECDSA-P256" to "id-SPHINCSplusSHA256-ECDSA-P256" because the public key format does not depend on the signature algorithm parameters.
- The following algorithms were removed:
  - pk-example-ECandRSA
  - id-Dilithium5-Falcon1024-ECDSA-P521
  - id-Dilithium5-Falcon1024-RSA
  - id-Kyber512-RSA
- The following algorithms were added:
  - id-Dilithium3-EDSA-brainpoolP256r1
  - id-Dilithium3-Ed25519
  - id-Dilithium5-ECDSA-P384
  - id-Dilithium5-ECDSA-brainpoolP384r1
  - id-Dilithium5-Ed448
  - id-Falcon512-ECDSA-brainpoolP256r1
  - id-SPHINCSplusSHA256-ECDSA-brainpoolP256r1
  - id-SPHINCSplusSHA256-Ed25519
  - id-Kyber512-ECDH-brainpoolP256r1
  - id-Kyber768-RSA
  - id-Kyber768-ECDH-P256
  - id-Kyber768-ECDH-brainpoolP256r1
  - id-Kyber768-X25519
  - id-Kyber1024-ECDH-P384
  - id-Kyber1024-ECDH-brainpoolP384r1
  - id-Kyber1024-X448
- Changed "examples" to "samples" when referring to {{appdx-samples}}.

# Terminology {#sec-terminology}
{::boilerplate bcp14}

This document is consistent with all terminology from {{I-D.driscoll-pqt-hybrid-terminology}}.

In addition, the following terms are used in this document:


BER:
          Basic Encoding Rules (BER) as defined in [X.690].

CLIENT:
          Any software that is making use of a cryptographic key.
          This includes a signer, verifier, encrypter, decrypter.
      

DER:
          Distinguished Encoding Rules as defined in [X.690].


PKI:
          Public Key Infrastructure, as defined in [RFC5280].


# Introduction {#sec-intro}

During the transition to post-quantum cryptography (PQ or PQC), there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, but we may also not fully trust their post-quantum replacements until further time has passed to allow additional scrutiny and the discovery of implementation bugs. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms by using a Post-Quantum/Traditional (PQ/T) or Post-Quantum/Post-Quantum (PQ/PQ) Hybrid scheme.

The transition to PQC will face two challenges:

- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Migration: During the transition period, systems will require mechanisms that allow for staged migrations from fully traditional to fully post-quantum-aware cryptography.

This document provides the composite mechanism, which is a specific instantiation of the PQ/T hybrid paradigm to address algorithm strength uncertainty concerns by providing formats for encoding multiple public key and private key values into existing public key and private key fields. Backwards compatibility is not directly addressed via the composite mechanisms defined in the document, but some notes on how it can be obtained can be found in {{sec-backwards-compat}}.

This document only specifies key formats; usage of these keys are covered in the corresponding composite signatures {{I-D.ounsworth-pq-composite-sigs}} and composite KEM {{I-D.ounsworth-pq-composite-kem}} specifications.

This document is intended for general applicability anywhere that keys are used within PKIX or CMS structures.


<!-- End of Introduction section -->


# Composite Key Structures {#sec-composite-keys}

In order to represent public keys and private keys that are composed of multiple algorithms, we define encodings consisting of a sequence of public key or private key primitives (aka "components") such that these structures can be used directly in existing public key fields such as those found in PKCS#10 [RFC2986], CMP [RFC4210], X.509 [RFC5280], CMS [RFC5652], and the Trust Anchor Format [RFC5914].

{{I-D.driscoll-pqt-hybrid-terminology}} defines composites as:

>   *Composite Cryptographic Element*:  A cryptographic element that
>      incorporates multiple component cryptographic elements of the same
>      type in a multi-algorithm scheme.

Composite keys as defined here follow this definition and should be regarded as a single key that performs a single cryptographic operation such key generation, signing, verifying, encapsulating, or decapsulating -- using its encapsulated sequence of component keys as if it was a single key. This generally means that the complexity of combining algorithms can and should be ignored by application and protocol layers and deferred to the cryptographic library layer.

## Specifying Composite Key Types

The following is the mandatory to specify information when specifying a composite key type:

* An AlgorithmIdentifier OID for the composite key type.
* Component public key types, AlgorithmIdentifiers and parameters for each position within the `CompositePublicKey`. (see {{sec-composite-pub-keys}}).
* Component private key types, AlgorithmIdentifiers and parameters for each position within the `CompositePrivateKey` (see {{sec-priv-key}}).


The following ASN.1 Information Object Class applies to all composite key types, with suitable replacements for the ASN.1 identifier `pk-Composite` and the OID `id-composite-key` as appropriate.

~~~ ASN.1
pk-Composite PUBLIC-KEY ::= {
    id id-composite-key
    KeyValue CompositePublicKey
    Params ARE ABSENT
    PrivateKey CompositePrivateKey
}
~~~
{: artwork-name="CompositeAlgorithmObject-asn.1-structures"}

`keyUsage` is omitted here because composites may be formed for keys of any type, provided that any key usage specified MUST apply to all component keys. Composites MAY NOT be used to combine key types, for example to make a "dual-usage" key by combining a signing key with a KEM key.


## CompositePublicKey {#sec-composite-pub-keys}

Composite public key data is represented by the following structure:

~~~ ASN.1
CompositePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo
~~~
{: artwork-name="CompositePublicKey-asn.1-structures"}


A composite key MUST contain at least two component public keys.

A CompositePublicKey MUST NOT contain a component public key which itself describes a composite key; i.e. recursive CompositePublicKeys are not allowed. The purpose is a general reduction in complexity by not needing to consider nested key types.

Each element of a CompositePublicKey is a SubjectPublicKeyInfo object encoding a component public key. Each component SubjectPublicKeyInfo SHALL contain an AlgorithmIdentifier OID which identifies the public key type and parameters for the public key contained within it. See {{sec-alg-ids}} for specific algorithms defined in this document.

When the CompositePublicKey must be provided in octet string or bit string format, the data structure is encoded as specified in {{sec-encoding-rules}}.

### Key Usage

For protocols such as X.509 [RFC5280] that specify key usage along with the public key, any key usage may be used with composite keys, with the requirement that the specified key usage MUST apply to all component keys. For example if a composite key is marked with a KeyUsage of digitalSignature, then all component keys MUST be capable of producing digital signatures. The composite mechanism MUST NOT be used to implement mixed-usage keys, for example, where a digitalSignature and a keyEncipherment key are combined together into a single composite key.


### Component Matching {#sec-component-matching}

Many cryptographic libraries will require treating each component key independently and thus expect a full SubjectPublicKeyInfo for each component at some layer of the software stack. This left two design choices: either we carry full SPKI for each component within the CompositePublicKey, or we compress it by only carrying the raw key bytes and force implementations to carry OID and parameter mapping tables to be able to reconstruct component SPKIs. 

The authors decided to carry the full SPKIs in order to lessen the implementation complexity. This also leads to the same wire format between explicitly specified combinations and generic composites {{sec-generic-composite}}.

This design choice has a non-obvious security risk in that the `algorithm` carried within each component SPKI is redundant information which MUST match -- and can be inferred from -- the specification of the explicit algorithm. 

Security consideration: Implementations SHOULD check that the component AlgorithmIdentifier OIDs and parameters match those expected by the definition of the explicit algorithm. Implementations SHOULD first parse a component's `SubjectPublicKeyInfo.algorithm`, and ensure that it matches what is expected for that position in the explicit key, and then proceed to parse the `SubjectPublicKeyInfo.subjectPublicKey`. This is to reduce the attack surface associated with parsing the public key data of an unexpected key type, or worse; to parse and use a key which does not match the explicit algorithm definition. Similar checks SHOULD be done when handling the corresponding private key.



## CompositePrivateKey {#sec-priv-key}

This section provides an encoding for composite private keys intended for PKIX protocols and other applications that require an interoperable format for transmitting private keys, such as PKCS #12 [RFC7292] or CMP / CRMF [RFC4210], [RFC4211]. It is not intended to dictate a storage format in implementations not requiring interoperability of private key formats.

In some cases the private keys that comprise a composite key may not be represented in a single structure or even be contained in a single cryptographic module. The establishment of correspondence between public keys in a CompositePublicKey and private keys not represented in a single composite structure is beyond the scope of this document.


The composite private key data is represented by the following structure:

~~~ ASN.1
CompositePrivateKey ::= SEQUENCE SIZE (2..MAX) OF OneAsymmetricKey
~~~
{: artwork-name="CompositePrivateKey-asn.1-structures"}

Each element is a OneAsymmetricKey [RFC5958] object for a component private key.

The parameters field MUST be absent.

A CompositePrivateKey MUST contain at least two component private keys, and they MUST be in the same order as in the corresponding CompositePublicKey.




## Encoding Rules {#sec-encoding-rules}
<!-- EDNOTE 7: Examples of how other specifications specify how a data structure is converted to a bit string can be found in RFC 2313, section 10.1.4, 3279 section 2.3.5, and RFC 4055, section 3.2. -->

Many protocol specifications will require that the composite public key and composite private key data structures be represented by an octet string or bit string.

When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.

~~~ ASN.1
CompositePublicKeyOs ::= OCTET STRING (CONTAINING CompositePublicKey ENCODED BY der)
~~~

When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

~~~ ASN.1
CompositePublicKeyBs ::= BIT STRING (CONTAINING CompositePublicKey ENCODED BY der)
~~~


# Algorithm Identifiers {#sec-alg-ids}

This section defines algorithm identifiers for composite combinations. The combinations registered in this section are intended to strike a balance between the overall number of combinations ("the combinatorial explosion problem"), while also covering the needs of a wide range of protocols, applications, and regulatory environments in which X.509-based technologies are used. 

This section is not intended to be exhaustive and other authors may define OIDs for new combinations so long as they are compatible with the structures and processes defined in this and the companion signature and encryption documents.


Signature public key types:

Signature key type                    | Definition                            | OID
 ---------                            | ----------                            | ------------
id-Dilithium3-RSA                     | {{sec-id-Dilithium3-RSA}}             | 2.16.840.1.114027.80.5.2 (for prototyping only)
id-Dilithium3-ECDSA-P256              | {{sec-id-Dilithium3-ECDSA-P256}}      | 2.16.840.1.114027.80.5.1 (for prototyping only)
id-Dilithium3-ECDSA-brainpoolP256r1   | {{sec-id-Dilithium3-ECDSA-brainpoolP256r1}} | TBD
id-Dilithium3-Ed25519                 | {{sec-id-Dilithium3-Ed25519}}         | TBD
id-Dilithium5-ECDSA-P384              | {{sec-id-Dilithium5-ECDSA-P384}}      | TBD
id-Dilithium5-ECDSA-brainpoolP384r1   | {{sec-id-Dilithium5-ECDSA-brainpoolP384r1}}  | TBD
id-Dilithium5-Ed448                   | {{sec-id-Dilithium5-Ed448}}           | TBD
id-Falcon512-ECDSA-P256               | {{sec-id-Falcon512-ECDSA-P256}}       | 2.16.840.1.114027.80.5.3 (for prototyping only)
id-Falcon512-ECDSA-brainpoolP256r1    | {{sec-id-Falcon512-ECDSA-brainpoolP256r1}}   | TBD
id-Falcon512-Ed25519                  | {{sec-id-Falcon512-Ed25519}}          | TBD
id-SPHINCSplusSHA256-ECDSA-P256       | {{sec-id-SPHINCSplusSHA256-ECDSA-P256}} | TBD
id-SPHINCSplusSHA256-ECDSA-brainpoolP256r1  | {{sec-id-SPHINCSplusSHA256-ECDSA-brainpoolP256r1}} | TBD
id-SPHINCSplusSHA256-Ed25519          | {{sec-id-SPHINCSplusSHA256-Ed25519}}  | TBD
id-composite-key                      | {{sec-generic-composite}}                         | TBD
{: #tab-sig-agls title="Composite signatures key types"}



KEM public key types:


KEM key type                       | Definition                                | OID
---------                          | -----------                               | ----------
id-Kyber512-ECDH-P256              | {{sec-id-Kyber512-ECDH-P256}}             | TBD
id-Kyber512-ECDH-brainpoolP256r1   | {{sec-id-Kyber512-ECDH-brainpoolP256r1}}  | TBD
id-Kyber512-X25519                 | {{sec-id-Kyber512-X25519}}                | TBD
id-Kyber768-RSA                    | {{sec-id-Kyber768-RSA}}                   | TBD
id-Kyber768-ECDH-P256              | {{sec-id-Kyber768-ECDH-P256}}             | TBD
id-Kyber768-ECDH-brainpoolP256r1   | {{sec-id-Kyber768-ECDH-brainpoolP256r1}}  | TBD
id-Kyber768-X25519                 | {{sec-id-Kyber768-X25519}}                | TBD
id-Kyber1024-ECDH-P384             | {{sec-id-Kyber1024-ECDH-P384}}            | TBD
id-Kyber1024-ECDH-brainpoolP384r1  | {{sec-id-Kyber1024-ECDH-brainpoolP384r1}} | TBD
id-Kyber1024-X448                  | {{sec-id-Kyber1024-X448}}                 | TBD
id-composite-key                   | {{sec-generic-composite}}                 | TBD
{: #tab-kem-agls title="Composite KEM key types"}



These combinations were chosen according to the following rough guidelines:

1. One RSA combination is provided (but RSA modulus size not mandated), matched with NIST PQC Level 3 algorithms.
1. NIST [RFC6090], Edwards [RFC7748], and Brainpool [RFC5639] elliptic curve algorithms are provided. NIST PQC Levels 1 - 3 algorithms are matched with 256-bit curves, while NIST levels 4 - 5 are matched with 384-bit elliptic curves. This provides a balance between matching classical security levels of post-quantum and traditional algorithms, and also selecting elliptic curves which already have wide adoption.
1. NIST level 1 candidates (Falcon512 and Kyber512) are provided, matched with 256-bit elliptic curves, intended for constrained use cases.
1. A single SPHINCS+ combination is provided for use cases that wish to put even hash-based signatures into hybrid combination.
1. A generic composite OID is provided for implementers who wish to use combinations not listed here, without the overhead of defining new OIDs. Caution should be exercised to avoid issues with compatibility and complex cryptographic policy mechanisms.

The authors wish to note that although the CompositePublicKey and CompositePrivateKey structures are defined in such a way as to easily allow 3 or more component keys, it was decided at the time of writing to only specify explicit pairs. The generic composite specified in {{sec-generic-composite}} of course allows for an arbitrary number of components. This also does not preclude future specification of explicit combinations with three or more components.


### id-Dilithium3-RSA {#sec-id-Dilithium3-RSA}


The following object identifier represents the id-Dilithium3-RSA key type:

~~~ asn1
id-Dilithium3-RSA OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Dilithium3-RSA(2) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.

The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-dilithium3TBD
      },
     subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)
}
~~~

where pk-dilithium3TBD and TBDDilithiumPublicKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.

> EDNOTE: `pk-dilithium3TBD` and `TBDPublicKey` refer to {{I-D.ietf-lamps-dilithium-certificates}} and should be kept in sync with future versions of that draft.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm rsaEncryption,
            parameters NULL
      },
     subjectPublicKey     BIT STRING(RSAPublicKey)
}
~~~

where rsaEncryption and RSAPublicKey are defined in [RFC8017].



The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-dilithium3TBD
  },
  privateKey DilithiumPrivateKey
}
~~~

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm rsaEncryption,
    parameters NULL
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480].

The publicKey remains OPTIONAL.

<!-- END id-Dilithium3-RSA -->


## id-Dilithium3-ECDSA-P256 {#sec-id-Dilithium3-ECDSA-P256}

The following object identifier is defined:

~~~ asn1
id-Dilithium3-ECDSA-P256 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Dilithium3-ECDSA-P256(1) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-dilithium3TBD
      },
     subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)
}
~~~

where pk-dilithium3TBD and TBDDilithiumPublicKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.

> EDNOTE: `pk-dilithiumTBD` and `TBDPublicKey` refer to {{I-D.ietf-lamps-dilithium-certificates}} and should be kept in sync with future versions of that draft.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters secp256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey, secp256r1, and ECPoint are defined in [RFC5480].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-dilithium3TBD
  },
  privateKey DilithiumPrivateKey
}
~~~

where id-dilithium3TBD and DilithiumPrivateKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters secp256r1
  },
  privateKey ECPrivateKey
}
~~~

where id-ecPublicKey, secp256r1, ECPrivateKey is defined in [RFC5480].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.

<!-- END id-Dilithium3-ECDSA-P256 -->



## id-Dilithium3-EDSA-brainpoolP256r1 {#sec-id-Dilithium3-ECDSA-brainpoolP256r1}

The following object identifier is defined:

~~~ asn1
id-Dilithium3-ECDSA-brainpoolP256r1 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Dilithium3-ECDSA-brainpoolP256r1(TODO) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-dilithium3TBD
      },
     subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)
}
~~~

where pk-dilithium3TBD and TBDDilithiumPublicKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.

> EDNOTE: `pk-dilithiumTBD` and `TBDPublicKey` refer to {{I-D.ietf-lamps-dilithium-certificates}} and should be kept in sync with future versions of that draft.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters brainpoolP256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey and ECPoint are defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.



The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-dilithium3TBD
  },
  privateKey DilithiumPrivateKey
}
~~~

where id-dilithium3TBD and DilithiumPrivateKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters brainpoolP256r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.

The publicKey remains OPTIONAL.

<!-- END id-Dilithium3_ECDSA-brainpoolP256r1 -->


## id-Dilithium3-Ed25519 {#sec-id-Dilithium3-Ed25519}

The following object identifier is defined:

~~~ asn1
id-Dilithium3-Ed25519 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Dilithium3-Ed25519(TODO) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-dilithium3TBD
      },
     subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)
}
~~~

where pk-dilithium3TBD are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.

> EDNOTE: `pk-dilithiumTBD` and `TBDPublicKey` refer to {{I-D.ietf-lamps-dilithium-certificates}} and should be kept in sync with future versions of that draft.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-Ed25519
      },
     subjectPublicKey     BIT STRING
}
~~~

where id-Ed25519 and the public key encoding are defined in [RFC8410].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-dilithium3TBD
  },
  privateKey DilithiumPrivateKey
}
~~~

where id-dilithium3TBD and DilithiumPrivateKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-Ed25519
  },
  privateKey OCTET STRING
}
~~~

where id-Ed25519 and the private key encoding are defined in [RFC8410].

The publicKey remains OPTIONAL.

<!-- END id-Dilithium3-ECDSA-Ed25519 -->

## id-Dilithium5-ECDSA-P384 {#sec-id-Dilithium5-ECDSA-P384}


The following object identifier is defined:

~~~ asn1
id-Dilithium5-ECDSA-P384 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Dilithium5-ECDSA-P384(TODO) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-dilithium5TBD
      },
     subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)
}
~~~

where `pk-dilithium5TBD` is defined in {{I-D.ietf-lamps-dilithium-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.

> EDNOTE: `pk-dilithiumTBD` and `TBDPublicKey` refer to {{I-D.ietf-lamps-dilithium-certificates}} and should be kept in sync with future versions of that draft.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters secp384r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey, secp384r1, and ECPoint are defined in [RFC5480].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-dilithium5TBD
  },
  privateKey DilithiumPrivateKey
}
~~~

where id-dilithium5TBD and DilithiumPrivateKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters secp384r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.

<!-- END id-Dilithium5-ECDSA-P384 -->

## id-Dilithium5-ECDSA-brainpoolP384r1 {#sec-id-Dilithium5-ECDSA-brainpoolP384r1}

The following object identifier is defined:

~~~ asn1
id-Dilithium5-ECDSA-brainpoolP384r1 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Dilithium5-ECDSA-brainpoolP384r1(TODO) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-dilithium5TBD
      },
     subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)
}
~~~

where pk-dilithium5TBD and TBDDilithiumPublicKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(DilithiumPublicKey)` is correct ASN.1.

> EDNOTE: `pk-dilithium5TBD` and `TBDPublicKey` refer to {{I-D.ietf-lamps-dilithium-certificates}} and should be kept in sync with future versions of that draft.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters brainpoolP384r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey and ECPoint are defined in [RFC5480], and `brainpoolP384r1` is defined in [RFC5639].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.



The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-dilithium5TBD
  },
  privateKey DilithiumPrivateKey
}
~~~

where id-dilithium5TBD and DilithiumPrivateKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters brainpoolP256r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.

The publicKey remains OPTIONAL.

<!-- END id-Dilithium5-ECDSA-brainpoolP384r1 -->



## id-Dilithium5-Ed448 {#sec-id-Dilithium5-Ed448}


The following object identifier is defined:

~~~ asn1
id-Dilithium5-Ed448 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Dilithium5-Ed448(TODO) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-dilithium5TBD
      },
     subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)
}
~~~

where pk-dilithium3TBD are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.

> EDNOTE: `pk-dilithium5TBD` and `TBDDilithiumPublicKey` refer to {{I-D.ietf-lamps-dilithium-certificates}} and should be kept in sync with future versions of that draft.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-Ed448
      },
     subjectPublicKey     BIT STRING
}
~~~

where id-Ed448 and the public key encoding are defined in [RFC8410].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-dilithium5TBD
  },
  privateKey DilithiumPrivateKey
}
~~~

where id-dilithium5TBD and DilithiumPrivateKey are defined in {{I-D.ietf-lamps-dilithium-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-Ed448
  },
  privateKey OCTET STRING
}
~~~

where id-Ed448 and the private key encoding are defined in [RFC8410].

The publicKey remains OPTIONAL.

<!-- END id-Dilithium5-Ed448 -->



## id-Falcon512-ECDSA-P256 {#sec-id-Falcon512-ECDSA-P256}

The following object identifier is defined:

~~~ asn1
id-Falcon512-ECDSA-P256 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Falcon512-ECDSA-P256(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-falcon512TBD
      },
     subjectPublicKey     BIT STRING(TBDFalconPublicKey)
}
~~~

> TODO: I don't think LAMPS has a FALCON draft yet. Will need to reference one once it exists.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters secp256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey, secp256r1, and ECPoint are defined in [RFC5480].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-falcon512TBD,
  },
  privateKey FalconPrivateKey
}
~~~

> TODO: I don't think LAMPS has a FALCON draft yet. Will need to reference one once it exists.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters secp256r1
  },
  privateKey ECPrivateKey
}
~~~

where id-ecPublicKey, secp256r1, ECPrivateKey is defined in [RFC5480].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.

<!-- id-Falcon512-ECDSA-P256 -->

## id-Falcon512-ECDSA-brainpoolP256r1 {#sec-id-Falcon512-ECDSA-brainpoolP256r1}

The following object identifier is defined:

~~~ asn1
id-Falcon512-ECDSA-brainpoolP256r1 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Falcon512-ECDSA-brainpoolP256r1(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-falcon512TBD
      },
     subjectPublicKey     BIT STRING(TBDFalconPublicKey)
}
~~~

> TODO: I don't think LAMPS has a FALCON draft yet. Will need to reference one once it exists.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters brainpoolP384r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey and ECPoint are defined in [RFC5480], and `brainpoolP384r1` is defined in [RFC5639].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-falcon512TBD
  },
  privateKey FalconPrivateKey
}
~~~

> TODO: I don't think LAMPS has a FALCON draft yet. Will need to reference one once it exists.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters brainpoolP256r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.

The publicKey remains OPTIONAL.

<!-- END id-Falcon512-ECDSA-brainpoolP256r1 -->




## id-Falcon512-Ed25519 {#sec-id-Falcon512-Ed25519}


The following object identifier is defined:

~~~ asn1
id-Falcon512-Ed25519 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Falcon512-Ed25519(3) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-falcon512TBD
      },
     subjectPublicKey     BIT STRING(TBDFalconPublicKey)
}
~~~

> TODO: I don't think LAMPS has a FALCON draft yet. Will need to reference one once it exists.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-Ed25519
      },
     subjectPublicKey     BIT STRING
}
~~~

where id-Ed25519 and the public key encoding are defined in [RFC8410].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-falcon512TBD
  },
  privateKey FalconPrivateKey
}
~~~

> TODO: I don't think LAMPS has a FALCON draft yet. Will need to reference one once it exists.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-Ed25519
  },
  privateKey OCTET STRING
}
~~~

where id-Ed25519 and the private key encoding are defined in [RFC8410].

The publicKey remains OPTIONAL.

<!-- END id-Falcon512-Ed25519 -->

## id-SPHINCSplusSHA256-ECDSA-P256 {#sec-id-SPHINCSplusSHA256-ECDSA-P256}

The following object identifier is defined:

~~~ asn1
id-SPHINCSplusSHA256-ECDSA-P256 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-SPHINCSplusSHA256-ECDSA-P256(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm pk-sphincs-plus-256
      },
     subjectPublicKey     BIT STRING(SPHINCS-Plus-PublicKey)
}
~~~

where pk-sphincs-plus-256 and SPHINCS-Plus-PublicKey are defined in {{I-D.ietf-lamps-cms-sphincs-plus}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters secp256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey, secp256r1, and ECPoint are defined in [RFC5480].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm pk-sphincs-plus-256
  },
  privateKey SPHINCS-Plus-PrivateKey
}
~~~

where pk-sphincs-plus-256 and SPHINCS-Plus-PrivateKey are defined in {{I-D.ietf-lamps-cms-sphincs-plus}}

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters secp256r1
  },
  privateKey ECPrivateKey
}
~~~

where id-ecPublicKey, secp256r1, ECPrivateKey is defined in [RFC5480].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.


<!-- END id-SPHINCSplusSHA256-ECDSA-P256 -->


## id-SPHINCSplusSHA256-ECDSA-brainpoolP256r1 {#sec-id-SPHINCSplusSHA256-ECDSA-brainpoolP256r1}

The following object identifier is defined:

~~~ asn1
id-SPHINCSplusSHA256-ECDSA-P256 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-SPHINCSplusSHA256-ECDSA-P256(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm pk-sphincs-plus-256
      },
     subjectPublicKey     BIT STRING(SPHINCS-Plus-PublicKey)
}
~~~

where pk-sphincs-plus-256 and SPHINCS-Plus-PublicKey are defined in {{I-D.ietf-lamps-cms-sphincs-plus}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters brainpoolP384r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey and ECPoint are defined in [RFC5480], and `brainpoolP384r1` is defined in [RFC5639].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm pk-sphincs-plus-256
  },
  privateKey SPHINCS-Plus-PrivateKey
}
~~~

where pk-sphincs-plus-256 and SPHINCS-Plus-PrivateKey are defined in {{I-D.ietf-lamps-cms-sphincs-plus}}

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters brainpoolP256r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5639] section 4.2.

The publicKey remains OPTIONAL.

<!-- END id-SPHINCSplusSHA256-ECDSA-brainpoolP256r1 -->


## id-SPHINCSplusSHA256-Ed25519 {#sec-id-SPHINCSplusSHA256-Ed25519}

The following object identifier is defined:

~~~ asn1
id-SPHINCSplusSHA256-Ed25519 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-SPHINCSplusSHA256-Ed25519(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm pk-sphincs-plus-256
      },
     subjectPublicKey     BIT STRING(SPHINCS-Plus-PublicKey)
}
~~~

where pk-sphincs-plus-256 and SPHINCS-Plus-PublicKey are defined in {{I-D.ietf-lamps-cms-sphincs-plus}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-Ed25519
      },
     subjectPublicKey     BIT STRING
}
~~~

where id-Ed25519 and the public key encoding are defined in [RFC8410].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm pk-sphincs-plus-256
  },
  privateKey SPHINCS-Plus-PrivateKey
}
~~~

where pk-sphincs-plus-256 and SPHINCS-Plus-PrivateKey are defined in {{I-D.ietf-lamps-cms-sphincs-plus}}

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-Ed25519
  },
  privateKey OCTET STRING
}
~~~

where id-Ed25519 and the private key encoding are defined in [RFC8410].

The publicKey remains OPTIONAL.


<!-- END id-SPHINCSplusSHA256-ECDSA-P256 -->



## id-Kyber512-ECDH-P256 {#sec-id-Kyber512-ECDH-P256}


The following object identifier is defined:

~~~ asn1
id-Kyber512-ECDH-P256 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber512-ECDH-P256(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber512TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber512TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters secp256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey, secp256r1, and ECPoint are defined in [RFC5480].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber512TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber512TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters secp256r1
  },
  privateKey ECPrivateKey
}
~~~

where id-ecPublicKey, secp256r1, ECPrivateKey is defined in [RFC5480].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.


<!-- END id-Kyber512-ECDH-P256 -->


## id-Kyber512-ECDH-brainpoolP256r1 {#sec-id-Kyber512-ECDH-brainpoolP256r1}

The following object identifier is defined:

~~~ asn1
id-Kyber512-ECDH-brainpoolP256r1 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber512-ECDH-brainpoolP256r1 (TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber512TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber512TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.


The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters brainpoolP256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey and ECPoint are defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber512TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber512TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters brainpoolP256r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The publicKey remains OPTIONAL.


<!-- END id-Kyber512-ECDH-brainpoolP256r1 -->


## id-Kyber512-X25519 {#sec-id-Kyber512-X25519}

The following object identifier is defined:

~~~ asn1
id-Kyber512-X25519 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber512-X25519(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber512TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber512TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-X25519
      },
     subjectPublicKey     BIT STRING
}
~~~

where id-X25519 and the public key encoding are defined in [RFC8410].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber512TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber512TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-X25519
  },
  privateKey OCTET STRING
}
~~~

where id-X25519 and the private key encoding are defined in [RFC8410].

The publicKey remains OPTIONAL.

<!-- END id-Kyber512-X25519 -->



## id-Kyber768-RSA {#sec-id-Kyber768-RSA}

The following object identifier is defined:

~~~ asn1
id-Kyber768-RSA OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber768-RSA(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber768TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber512TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm rsaEncryption,
            parameters NULL
      },
     subjectPublicKey     BIT STRING(RSAPublicKey)
}
~~~

where rsaEncryption and RSAPublicKey are defined in [RFC8017].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber768TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber768TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm rsaEncryption,
            parameters NULL
      },
     subjectPublicKey     BIT STRING(RSAPrivateKey)
}
~~~

where rsaEncryption and RSAPrivateKey are defined in [RFC8017].

The publicKey remains OPTIONAL.


<!-- END id-Kyber768-RSA -->


## id-Kyber768-ECDH-P256 {#sec-id-Kyber768-ECDH-P256}

The following object identifier is defined:

~~~ asn1
id-Kyber768-ECDH-P256 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber768-ECDH-P256(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber768TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber768TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters secp256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey, secp256r1, and ECPoint are defined in [RFC5480].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber768TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber768TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters secp256r1
  },
  privateKey ECPrivateKey
}
~~~

where id-ecPublicKey, secp256r1, ECPrivateKey is defined in [RFC5480].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.

<!-- END id-Kyber768-ECDH-P256 -->


## id-Kyber768-ECDH-brainpoolP256r1 {#sec-id-Kyber768-ECDH-brainpoolP256r1}

The following object identifier is defined:

~~~ asn1
id-Kyber768-ECDH-P256 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber768-ECDH-P256(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber768TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber768TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters brainpoolP256r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey and ECPoint are defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber768TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber768TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters brainpoolP256r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480], and `brainpoolP256r1` is defined in [RFC5639].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.


<!-- id-Kyber768-ECDH-brainpoolP256r1 -->


## id-Kyber768-X25519 {#sec-id-Kyber768-X25519}


The following object identifier is defined:

~~~ asn1
id-Kyber767-X25519 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber768-X25519(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber768TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber768TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-X25519
      },
     subjectPublicKey     BIT STRING
}
~~~

where id-X25519 and the public key encoding are defined in [RFC8410].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber768TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber768TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-X25519
  },
  privateKey OCTET STRING
}
~~~

where id-X25519 and the private key encoding are defined in [RFC8410].

The publicKey remains OPTIONAL.

<!-- END id-Kyber768-X25519 -->


## id-Kyber1024-ECDH-P384 {#sec-id-Kyber1024-ECDH-P384}

The following object identifier is defined:

~~~ asn1
id-Kyber1024-ECDH-P384 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber1024-ECDH-P384(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber1024TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber1024TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters secp384r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey, secp384r1, and ECPoint are defined in [RFC5480].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber1024TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber768TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters secp384r1
  },
  privateKey ECPrivateKey
}
~~~

where id-ecPublicKey, secp384r1, ECPrivateKey is defined in [RFC5480].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.


<!-- END id-Kyber1024-ECDH-P384 -->

## id-Kyber1024-ECDH-brainpoolP384r1 {#sec-id-Kyber1024-ECDH-brainpoolP384r1}

The following object identifier is defined:

~~~ asn1
id-Kyber1024-ECDH-brainpoolP384r1 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber1024-ECDH-brainpoolP384r1(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber1024TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber1024TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-ecPublicKey,
            parameters brainpoolP384r1
      },
     subjectPublicKey     BIT STRING(ECPoint)
}
~~~

where id-ecPublicKey and ECPoint are defined in [RFC5480], and `brainpoolP384r1` is defined in [RFC5639].
Alternatively, the `algorithm.algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber1024TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber1024TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-ecPublicKey,
    parameters brainpoolP384r1
  },
  privateKey ECPrivateKey
}
~~~

where ECPrivateKey is defined in [RFC5480], and `brainpoolP384r1` is defined in [RFC5639].
Alternatively, the `algorithm` MAY be `id-ecDH` or `id-ecMQV` in accordance with [RFC5480] section 2.1.

The publicKey remains OPTIONAL.


<!-- END id-Kyber1024-ECDH-brainpoolP384r1 -->




## id-Kyber1024-X448 {#sec-id-Kyber1024-X448}

The following object identifier is defined:

~~~ asn1
id-Kyber1024-X448 OBJECT IDENTIFIER ::= { 
  joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027) 
  algorithm(80) ExplicitCompositeKey(5) id-Kyber1024-X448(TBD) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

When used in an AlgorithmIdentifier, parameters SHALL be ABSENT.


The first public key component SubjectPublicKeyInfo (defined in [RFC5280]) SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
          algorithm id-kyber1024TBD
      },
     subjectPublicKey     BIT STRING(Kyber-PublicKey)
}
~~~

> TODO: id-kyber1024TBD and Kyber-PublicKey will eventually be defined in {{I-D.ietf-lamps-kyber-certificates}}.

> TODO: I don't think `subjectPublicKey     BIT STRING(TBDDilithiumPublicKey)` is correct ASN.1.



The second public key component SubjectPublicKeyInfo SHALL contain:

~~~ ASN.1
SEQUENCE  {
     algorithm  AlgorithmIdentifier {
            algorithm id-X448
      },
     subjectPublicKey     BIT STRING
}
~~~

where id-X448 and the public key encoding are defined in [RFC8410].


The first private key component OneAsymmetricKey, defined in [RFC5958] SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-kyber1024TBD
  },
  privateKey PqckemPrivateKey
}
~~~

where id-kyber1024TBD and PqckemPrivateKey are defined in {{I-D.ietf-lamps-kyber-certificates}}.

The publicKey remains OPTIONAL.


The second private key component OneAsymmetricKey SHALL contain

~~~
privateKeyAlgorithm AlgorithmIdentifier ::= {
    algorithm id-X448
  },
  privateKey OCTET STRING
}
~~~

where id-X448 and the private key encoding are defined in [RFC8410].

The publicKey remains OPTIONAL.


<!-- END id-Kyber1024-X448 -->


## id-composite-key (Generic Composite Keys) {#sec-generic-composite}

This key type is primarily for prototyping and for use in proprietary implementations where an application needs a combination that does not have a defined OID. The semantics are the same as above except that no consistency check is needed between the outer AlgorithmIdentifier OID and the AlgorithmIdentifier OIDs within the component SubjectPublicKeyInfos or OneAsymmetricKeys.

The id-composite-key object identifier is used for identifying a generic composite public key and a generic composite private key. This allows arbitrary combinations of key types to be placed in the CompositePublicKey and CompositePrivateKey structures without needing the combination to be pre-registered or standardized. 

~~~ asn.1
id-composite-key OBJECT IDENTIFIER ::= {
    joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027)
    Algorithm(80) Composite(4) CompositeKey(1) }
~~~

> EDNOTE: this is a temporary OID for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.

This section does not specify the contents of the component SubjectPublicKeyInfos or OneAsymmetricKeys since the purpose of this generic composite algorithm is to leave this flexible for runtime agents.

The motivation for this variant is primarily for prototyping work prior to the standardization of algorithm identifiers for explicit combinations of algorithms. However, the authors envision that this variant will remain relevant beyond full standardization for example in environments requiring very high levels of crypto agility, for example where clients support a large number of algorithms or where a large number of keys will be used at a time and it is therefore prohibitive to define algorithm identifiers for every combination of pairs, triples, quadruples, etc of algorithms.

<!-- END id-composite-key -->




# Implementation Considerations {#sec-imp-considers}

This section addresses practical issues of how this draft affects other protocols and standards.


> EDNOTE 10: Possible topics to address:

  - The size of these certs and cert chains.
  - In particular, implications for (large) composite keys / signatures / certs on the handshake stages of TLS and IKEv2.
  - If a cert in the chain is a composite cert then does the whole chain need to be of composite Certs?
  - We could also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs.


## Textual encoding of Composite Private Keys

CompositePrivateKeys can be encoded to the Privacy-Enhanced Mail (PEM) [RFC1421] format by placing a CompositePrivateKey into the privateKey field of a PrivateKeyInfo or OneAsymmetricKey object, and then applying the PEM encoding rules as defined in [RFC7468] section 10 and 11 for plaintext and encrypted private keys, respectively.


## Backwards Compatibility {#sec-backwards-compat}

As noted in the introduction, the post-quantum cryptographic migration will face challenges in both ensuring cryptographic strength against adversaries of unknown capabilities, as well as providing ease of migration. The composite mechanisms defined in this document primarily address cryptographic strength, however this section contains notes on how backwards compatibility may be obtained.

The term "ease of migration" is used here to mean that existing systems can be gracefully transitioned to the new technology without requiring large service disruptions or expensive upgrades. The term "backwards compatibility" is used here to mean something more specific; that existing systems, as they are deployed today, can interoperate with the upgraded systems of the future.

These migration and interoperability concerns need to be thought about in the context of various types of protocols that make use of X.509 and PKIX with relation to public key objects, from online negotiated protocols such as TLS 1.3 [RFC8446] and IKEv2 [RFC7296], to non-negotiated asynchronous protocols such as S/MIME signed and encrypted email [RFC8551], document signing such as in the context of the European eIDAS regulations [eIDAS2014], and publicly trusted code signing [codeSigningBRsv2.8], as well as myriad other standardized and proprietary protocols and applications that leverage CMS [RFC5652] signed or encrypted structures.


### OR modes

This document purposefully does not specify how clients are to combine component keys together to form a single cryptographic operation; this is left up to the specifications of signature and encryption algorithms that make use of the composite key type. One possible way to combine component keys is through an OR relation, or OR-like client policies for acceptable algorithm combinations, where senders and / or receivers are permitted to ignore some component keys. Some envisioned uses of this include environments where the client encounters a component key for which it does not possess a compatible algorithm implementation but wishes to proceed with the cryptographic operation using the subset of component keys for which it does have compatible implementations. Such a mechanism could be designed to provide ease of migration by allowing for composite keys to be distributed and used before all clients in the environment are fully upgraded, but it does not allow for full backwards compatibility since clients would at least need to be upgraded from their current state to be able to parse the composite structures.


### Parallel PKIs

We present the term "Parallel PKI" to refer to the setup where a PKI end entity possesses two or more distinct public keys or certificates for the same key type (signature, key establishment, etc) for the same identity (name, SAN), but containing keys for different cryptographic algorithms. One could imagine a set of parallel PKIs where an existing PKI using legacy algorithms (RSA, ECC) is left operational during the post-quantum migration but is shadowed by one or more parallel PKIs using pure post quantum algorithms or composite algorithms (legacy and post-quantum). This concept contains strong overlap with other documented approaches, such as {{I-D.becker-guthrie-noncomposite-hybrid-auth}} and highlights the synergy between composite and non-composite hybrid approaches.

Equipped with a set of parallel public keys in this way, a client would have the flexibility to choose which public key(s) or certificate(s) to use in a given cryptographic operation. 

For negotiated protocols, the client could choose which public key(s) or certificate(s) to use based on the negotiated algorithms, or could combine two of the public keys for example in a non-composite hybrid method such as {{I-D.becker-guthrie-noncomposite-hybrid-auth}} or {{I-D.guthrie-ipsecme-ikev2-hybrid-auth}}. Note that it is possible to use the signature algorithm defined in {{I-D.ounsworth-pq-composite-sigs}} as a way to carry the multiple signature values generated by a non-composite public mechanism in protocols where it is easier to support the composite signature algorithms than to implement such a mechanism in the protocol itself. There is also nothing precluding a composite public key from being one of the components used within a non-composite authentication operation; this may lead to greater convenience in setting up parallel PKI hierarchies that need to service a range of clients implementing different styles of post-quantum migration strategies.

For non-negotiated protocols, the details for obtaining backwards compatibility will vary by protocol, but for example in CMS [RFC5652], the inclusion of multiple SignerInfo or RecipientInfo objects is often already treated as an OR relationship, so including one for each of the end entity's parallel PKI public keys would, in many cases, have the desired effect of allowing the receiver to choose one they are compatible with and ignore the others, thus achieving full backwards compatibility.


<!-- End of In Practice section -->

# IANA Considerations {#sec-iana}

This document registers the following in the SMI "Security for PKIX Algorithms (1.3.6.1.5.5.7.6)" registry:

~~~ ASN.1
id-composite-key OBJECT IDENTIFIER ::= {
    iso(1) identified-organization(3) dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) algorithms(6) id-composite-key(??) }
~~~

<!-- End of IANA Considerations section -->


# Security Considerations

## Reuse of keys in a Composite public key {#sec-secCons-keyReuse}

There is an additional security consideration that some use cases such as signatures remain secure against downgrade attacks if and only if component keys are never used outside of their composite context and therefore it is RECOMMENDED that component keys in a composite key are not to be re-used in other contexts. In particular, the components of a composite key SHOULD NOT also appear in single-key certificates. This is particularly relevant for protocols that use composite keys in a logical AND mode since the appearance of the same component keys in single-key contexts undermines the binding of the component keys into a single composite key by allowing messages signed in a multi-key AND mode to be presented as if they were signed in a single key mode in what is known as a "stripping attack".

## Key mismatch in explicit composite

This security consideration copied from {{sec-component-matching}}.

Implementations SHOULD check that the component AlgorithmIdentifier OIDs and parameters match those expected by the definition of the explicit algorithm. Implementations SHOULD first parse a component's `SubjectPublicKeyInfo.algorithm`, and ensure that it matches what is expected for that position in the explicit key, and then proceed to parse the `SubjectPublicKeyInfo.subjectPublicKey`. This is to reduce the attack surface associated with parsing the public key data of an unexpected key type, or worse; to parse and use a key which does not match the explicit algorithm definition. Similar checks SHOULD be done when handling the corresponding private key.


## Policy for Deprecated and Acceptable Algorithms

Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that clients performing signature verification or encryption operations should be updated to fail to validate or refuse to encrypt for these algorithms.

In the composite model this is less obvious since implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though one or both algorithms are deprecated for individual use. As such, a single composite public key, certificate, signature, or ciphertext MAY contain a mixture of deprecated and non-deprecated algorithms. 

Specifying behaviour in these cases is beyond the scope of this document, but should be considered by implementers and potentially in additional standards.

> EDNOTE: Max had proposed a CRL mechanism to accomplish this, which could be revived if necessary.

## Protection of Private Keys

Structures described in this document do not protect private keys in any way unless combined with a security protocol or encryption properties of the objects (if any) where the CompositePrivateKey is used.

Protection of the private keys is vital to public key cryptography. The consequences of disclosure depend on the purpose of the private key. If a private key is used for signature, then the disclosure allows unauthorized signing. If a private key is used for key management, then disclosure allows unauthorized parties to access the managed keying material. The encryption algorithm used in the encryption process must be at least as 'strong' as the key it is protecting.

## Checking for Compromised Key Reuse

Certification Authority (CA) implementations need to be careful when checking for compromised key reuse, for example as required by WebTrust regulations; when checking for compromised keys, you MUST unpack the CompositePublicKey structure and compare individual component keys. In other words, for the purposes of key reuse checks, the composite public key structures need to be un-packed so that primitive keys are being compared. For example if the composite key {RSA1, PQ1} is revoked for key compromise, then the keys RSA1 and PQ1 need to be individually considered revoked. If the composite key {RSA1, PQ2} is submitted for certification, it SHOULD be rejected because the key RSA1 was previously declared compromised even though the key PQ2 is unique.



<!-- End of Security Considerations section -->

<!-- Start of Appendices -->
--- back

# Samples {#appdx-samples}

These samples are reproduced here for completeness, but are also available in github:

https://github.com/EntrustCorporation/draft-ounsworth-pq-composite-keys/tree/master/sampledata

> TODO: move these to https://github.com/lamps-wg before publication

## Generic Composite Public Key Samples {#appdx-genComposite-samples}

This is an example generic composite public key

~~~
!!ecp256rsapub.pem
~~~

which decodes as:

~~~
algorithm: AlgorithmIdentifier{id-composite-key}

subjectPublicKey: CompositePublicKey {
  SubjectPublicKeyInfo {
    algorithm: AlgorithmIdentifier {
      algorithm: ecPublicKey
      parameters: prime256v1
      }
    subjectPublicKey: <ec key octet string>
    },
    SubjectPublicKeyInfo {
    algorithm: AlgorithmIdentifier {
      algorithm: rsaEncryption
      parameters: NULL
      }
    subjectPublicKey: <rsa key octet string>
    }
  }
~~~


The corresponding explicit private key is as follows. Note that the PQ key comes from OpenQuantumSafe-openssl and is in the {privatekey \|\| publickey} concatenated format. This may cause interoperability issues with some clients, and also makes the private keys appear larger than they would be if generated by a non-openssl client.

~~~
!!ecp256rsapriv.pem
~~~

which decodes as:

~~~
algorithm: AlgorithmIdentifier{id-composite-key}

SEQUENCE {
  OneAsymmetricKey {
      version: 0,
      privateKeyAlgorithm: PrivateKeyAlgorithmIdentifier{
        algorithm: ecPublicKey 
        parameters: prime256v1
      }
      privateKey: <ec key octet string>
    },
  OneAsymmetricKey {
      version: 0,
      privateKeyAlgorithm: PrivateKeyAlgorithmIdentifier{
        algorithm: rsaEncryption 
        parameters: NULL
      }
      privateKey: <rsa key octet string>
    }
  }
~~~

## Explicit Composite Public Key Samples {#appdx-expComposite-samples}


### id-Dilithium3-ECDSA-P256


This example uses the following OID as defined in Open Quantum Safe, which correspond to NIST Round3 candidates:

https://github.com/open-quantum-safe/oqs-provider/blob/main/ALGORITHMS.md

~~~
id-dilithium3_aes 1.3.6.1.4.1.2.267.11.6.5
~~~

A Dilithium3-ECDSA-P256 public key:

~~~
!!id-Dilithium3-ECDSA-P256_pub.pem
~~~


The corresponding explicit private key is as follows. Note that the PQ key comes from OpenQuantumSafe-openssl and is in the {privatekey \|\| publickey} concatenated format. This may cause interoperability issues with some clients, and also makes the private keys appear larger than they would be if generated by a non-openssl client.

~~~
!!id-Dilithium3-ECDSA-P256_priv.pem
~~~


### id-Dilithium3-RSA


This example uses the following OID as defined in Open Quantum Safe, which correspond to NIST Round3 candidates:

https://github.com/open-quantum-safe/oqs-provider/blob/main/ALGORITHMS.md

~~~
id-dilithium3_aes 1.3.6.1.4.1.2.267.11.6.5
~~~

A Dilithium3-RSA public key:

~~~
!!id-Dilithium3-RSA_pub.pem
~~~

The corresponding explicit private key is as follows. Note that the PQ key comes from OpenQuantumSafe-openssl and is in the {privatekey \|\| publickey} concatenated format. This may cause interoperability issues with some clients, and also makes the private keys appear larger than they would be if generated by a non-openssl client.

~~~
!!id-Dilithium3-RSA_priv.pem
~~~


### id-Falcon512-ECDSA-P256


This example uses the following OID as definid in Open Quantum Safe, which correspond to NIST Round3 candidates:

https://github.com/open-quantum-safe/oqs-provider/blob/main/ALGORITHMS.md

~~~
id-falcon512 1.3.9999.3.1
~~~

A Falcon512-ECDSA-P256 public key:

~~~
!!id-Falcon512-ECDSA-P256_pub.pem
~~~

The corresponding explicit private key is as follows. Note that the PQ key comes from OpenQuantumSafe-openssl and is in the {privatekey \|\| publickey} concatenated format. This may cause interoperability issues with some clients, and also makes the private keys appear larger than they would be if generated by a non-openssl client.

~~~
!!id-Falcon512-ECDSA-P256_priv.pem
~~~



### id-SPHINCSplusSHA256256frobust-ECDSA-P256

> TODO: we switched to using a pub key identifier without the signing mode, ie just id-SPHINCSplusSHA256-ECDSA-P256


This example uses the following OID as definid in Open Quantum Safe:

https://github.com/open-quantum-safe/oqs-provider/blob/main/ALGORITHMS.md

~~~
id-SPHINCSplusSHA256256frobust 1.3.9999.6.6.1
~~~

A SPHINCSplusSHA256256frobust-ECDSA-P256 public key:

~~~
-----BEGIN PUBLIC KEY-----
MIG/MAwGCmCGSAGG+mtQBQcDga4AMIGqME0wCAYGK84PBgYBA0EA6HRU4f2vmr2LV5vZVlaniti
Ly8ZCfheVqolJGrY5GxpNwvIt8fK6swNtftSgmrC+fCDE48/fbzX7a2U3F1/S3TBZMBMGByqGSM
49AgEGCCqGSM49AwEHA0IABFjKamMP3nn7Ua8Y8XEJtqnp7ya+Ino3UoxjMhhVKHx0fQxAz7lB7
Eytrtq3H7e59JYdkceK1h+T8jZFyUP5e0M=
-----END PUBLIC KEY-----
~~~


which decodes as:

~~~
algorithm: AlgorithmIdentifier{id-Dilithium3-ECDSA-P256}

subjectPublicKey: CompositePublicKey {
  SubjectPublicKeyInfo {
    algorithm: AlgorithmIdentifier {
      algorithm: id-SPHINCSplusSHA256256frobust
      }
    subjectPublicKey: <sphincs key octet string>
    },
    SubjectPublicKeyInfo {
    algorithm: AlgorithmIdentifier {
      algorithm: ecPublicKey
      parameters: prime256v1
      }
    subjectPublicKey: <ec octet string>
    }
  }
           
~~~

The corresponding explicit private key is as follows. Note that the PQ key comes from OpenQuantumSafe-openssl and is in the {privatekey \|\| publickey} concatenated format. This may cause interoperability issues with some clients, and also makes the private keys appear larger than they would be if generated by a non-openssl client.

~~~
-----BEGIN PRIVATE KEY-----
MIIBMgIBADAMBgpghkgBhvprUAUHBIIBHTCCARkwgdMCAQAwCAYGK84PBgYBBIHDBIHA0PwPCww
Ulg3VLrZC7cGLqF0jRZrREj/l4kKF4JsLTjRR2P4RLqEm0qBa7ukb4ytHE6HDfM0h6dJ19F02hO
SO6Oh0VOH9r5q9i1eb2VZWp4rYi8vGQn4XlaqJSRq2ORsaTcLyLfHyurMDbX7UoJqwvnwgxOPP3
281+2tlNxdf0t3odFTh/a+avYtXm9lWVqeK2IvLxkJ+F5WqiUkatjkbGk3C8i3x8rqzA21+1KCa
sL58IMTjz99vNftrZTcXX9LdMEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCAwCM4
KKsZbXlaZBph1ixcUhlNiZ1qp4LnA90Nm/rArZw==
-----END PRIVATE KEY-----
~~~



# ASN.1 Module

~~~ ASN.1

<CODE STARTS>

Composite-Keys-2022

DEFINITIONS IMPLICIT TAGS ::= BEGIN

EXPORTS ALL;

IMPORTS
  PUBLIC-KEY, SIGNATURE-ALGORITHM, ParamOptions, AlgorithmIdentifier{}
    FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-algorithmInformation-02(58) }

  SubjectPublicKeyInfo
    FROM PKIX1Explicit-2009
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-pkix1-explicit-02(51) }

  OneAsymmetricKey
    FROM AsymmetricKeyPackageModuleV1
      { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
        pkcs-9(9) smime(16) modules(0)
        id-mod-asymmetricKeyPkgV1(50) } ;

--
-- Object Identifiers
--
 
der OBJECT IDENTIFIER ::=
  {joint-iso-itu-t asn1(1) ber-derived(2) distinguished-encoding(1)}

-- To be replaced by IANA
id-composite-key OBJECT IDENTIFIER ::= {
    joint-iso-itu-t(2) country(16) us(840) organization(1) entrust(114027)
    Algorithm(80) Composite(4) CompositeKey(1)



--  COMPOSITE-KEY-ALGORITHM
--
--  Describes the basic properties of a composite key algorithm
--
--  &id - contains the OID identifying the composite algorithm
--  &Params - if present, contains the type for the algorithm
--               parameters; if absent, implies no parameters
--  &paramPresence - parameter presence requirement
--
-- }

COMPOSITE-KEY-ALGORITHM ::= CLASS {
    &id             OBJECT IDENTIFIER UNIQUE,
    &Params         OPTIONAL,
    &paramPresence  ParamOptions DEFAULT absent
} WITH SYNTAX {
    IDENTIFIER &id
    [PARAMS [TYPE &Params] ARE &paramPresence ]
}


CompositeAlgorithmIdentifier ::= AlgorithmIdentifier{COMPOSITE-KEY-ALGORITHM, {CompositeAlgorithmSet}}

CompositeAlgorithmSet COMPOSITE-KEY-ALGORITHM ::= {
  CompositeAlgorithms, ...
}

--
-- Public Key
--

pk-Composite PUBLIC-KEY ::= {
    IDENTIFIER id-composite-key
    KEY CompositePublicKey
    PARAMS TYPE CompositeAlgorithmIdentifier ARE optional
    PRIVATE-KEY CompositePrivateKey
}

CompositePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo

CompositePublicKeyOs ::= OCTET STRING (CONTAINING CompositePublicKey ENCODED BY der)

CompositePublicKeyBs ::= BIT STRING (CONTAINING CompositePublicKey ENCODED BY der)

CompositePrivateKey ::= SEQUENCE SIZE (2..MAX) OF OneAsymmetricKey


-- pk-explicitComposite - Composite public key information object

pk-explicitComposite{OBJECT IDENTIFIER:id, PUBLIC-KEY:firstPublicKey,
  FirstPublicKeyType, PUBLIC-KEY:secondPublicKey, SecondPublicKeyType}
  PUBLIC-KEY ::= {
    IDENTIFIER id
    KEY ExplicitCompositePublicKey{firstPublicKey, FirstPublicKeyType,
      secondPublicKey, SecondPublicKeyType}
    PARAMS ARE absent
}

-- The following ASN.1 object class then automatically generates the
-- public key structure from the types defined in pk-explicitComposite.

-- ExplicitCompositePublicKey - The data structure for a composite
-- public key sec-composite-pub-keys and SecondPublicKeyType are needed
-- because PUBLIC-KEY contains a set of public key types, not a single
-- type.
-- TODO The parameters should be optional only if they are marked
-- optional in the PUBLIC-KEY


ExplicitCompositePublicKey{PUBLIC-KEY:firstPublicKey, FirstPublicKeyType,
  PUBLIC-KEY:secondPublicKey, SecondPublicKeyType} ::= SEQUENCE {
    firstPublicKey SEQUENCE {
        params firstPublicKey.&Params OPTIONAL,
        publicKey FirstPublicKeyType
    },
    secondPublicKey SEQUENCE {
        params secondPublicKey.&Params OPTIONAL,
        publicKey SecondPublicKeyType
    }
}

TODO: add all the OIDs

END

<CODE ENDS>

~~~


# Intellectual Property Considerations

The following IPR Disclosure relates to this draft:

https://datatracker.ietf.org/ipr/3588/



# Contributors and Acknowledgements
This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past year in pursuit of this document:

John Gray (Entrust),
Serge Mister (Entrust),
Scott Fluhrer (Cisco Systems),
Panos Kampanakis (Cisco Systems),
Daniel Van Geest (ISARA),
Tim Hollebeek (Digicert),
Klaus-Dieter Wirth (D-Trust), and
François Rousseau.

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

<!-- End of Contributors section -->


