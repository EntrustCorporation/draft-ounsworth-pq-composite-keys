---
title: Composite Public and Private Keys For Use In Internet PKI
abbrev: PQ Composite Keys
# <!-- EDNOTE: Edits the draft name -->
docname: draft-ounsworth-pq-composite-keys-01
# <!-- date: 2012-01-13 -->
# <!-- date: 2012-01 -->
# <!-- date: 2012 -->

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
wg: LAMPS
kw: Internet-Draft
cat: std

coding: us-ascii
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth (Editor)
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road – Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: mike.ounsworth@entrust.com

    -
      ins: M. Pala
      name: Massimiliano Pala
      org: CableLabs
      email: director@openca.org

    -
      ins: J. Klaussner
      name: Jan Klaussner
      org: D-Trust GmbH
      email: jan.klaussner@d-trust.net
      street: Kommandantenstr. 15
      code: 10969
      city: Berlin
      country: Germany

normative:
  RFC1421:
  RFC2119:
  RFC2986:
  RFC4210:
  RFC5280:
  RFC5652:
  RFC5914:
  RFC5958:
  RFC7468:
  RFC8174:
  RFC8411:
  X.690:
      title: "Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)"
      date: November 2015
      author:
        org: ITU-T
      seriesinfo:
        ISO/IEC: 8825-1:2015


# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  I-D.draft-ounsworth-pq-composite-sigs-05:
  Bindel2017:
    title: "Transitioning to a quantum-resistant public key infrastructure"
    target: "https://link.springer.com/chapter/10.1007/978-3-319-59879-6_22"
    author:
      -
        ins: N. Bindel
        name: Nina Bindel
      -
        ins: U. Herath
        name: Udyani Herath
      -
        ins: M. McKague
        name: Matthew McKague
      -
        ins: D. Stebila
        name: Douglas Stebila
    date: 2017

# <!--updates:
  # RFC2986
  # RFC5280
  # RFC5652 -->
# <!-- EDNOTE: does it update these anymore?? -->


# <!-- EDNOTE: Add RFC 3279? -->

--- abstract
With the widespread adoption of post-quantum cryptography will come the need for an entity to possess multiple public keys on different cryptographic algorithms. Since the trustworthiness of individual post-quantum algorithms is at question, a multi-key cryptographic operation will need to be performed in such a way that breaking it requires breaking each of the component algorithms individually. This requires defining new structures for holding composite keys, for use with composite signature and encryption data.

This document defines the structures CompositePublicKey, CompositePrivateKey, which are sequences of the respective structure for each component algorithm. The generic composite mode makes no assumptions about what the component algorithms are, provided that they have defined algorithm identifiers. The only requirement imposed by this document is that all algorithms be of the same key usage; i.e. all signature or all encryption. This document is intended to be coupled with corresponding documents that define the structure and semantics of composite signatures and encryption. This document also defines the explicit composite mode which allows for AlgorithmIdentifier.algorithm OIDs to be registered which specify an explicit combination of algorithms.

<!-- End of Abstract -->


--- middle

# Introduction {#sec-intro}

During the transition to post-quantum cryptography, there will be uncertainty as to the strength of cryptographic algorithms; we will no longer fully trust traditional cryptography such as RSA, Diffie-Hellman, DSA and their elliptic curve variants, but we will also not fully trust their post-quantum replacements until they have had sufficient scrutiny. Unlike previous cryptographic algorithm migrations, the choice of when to migrate and which algorithms to migrate to, is not so clear. Even after the migration period, it may be advantageous for an entity's cryptographic identity to be composed of multiple public-key algorithms.

The deployment of composite public keys, and composite signatures and composite encryption using post-quantum algorithms will face two challenges


- Algorithm strength uncertainty: During the transition period, some post-quantum signature and encryption algorithms will not be fully trusted, while also the trust in legacy public key algorithms will start to erode.  A relying party may learn some time after deployment that a public key algorithm has become untrustworthy, but in the interim, they may not know which algorithm an adversary has compromised.
- Migration: During the transition period, systems will require mechanisms that allow for staged migrations from fully classical to fully post-quantum-aware cryptography.

This document provides a mechanism to address both algorithm strength uncertainty as well as migration concerns by providing formats for encoding multiple public keys and private keys values into existing public key and private key fields.

This document is intended for general applicability anywhere that keys are used within PKIX or CMS structures.


EDNOTE
A previous version of this draft specified alternate algorithm identifiers for AND and OR modes. As well, a similar spec by D-Trust (now co-authors of this draft) also specified a "K of N" mode. While we still believe that these are valuable modes serving security and migration needs, we have removed them from this draft as they are really key usage policy and therefore do not belong in the public key object defined in this draft. They remain important parts of composite signature algorithms to prevent stripping attacks, and of composite encryption algorithms to tell a recipient how to decrypt the ciphertext. If the community decides that this usage information should accompany a composite public key, then it should be carried either as an X.509 Extended Key Usage or v3 Extension rather than in the public key itself.


<!-- End of Introduction section -->


## Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}}  {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

The following terms are used in this document:

ALGORITHM:
          An information object class for identifying the type of
            cryptographic key being encapsulated.

BER:
          Basic Encoding Rules (BER) as defined in [X.690].

COMPONENT ALGORITHM:
          A single basic algorithm which is contained within a
            composite algorithm.

COMPOSITE ALGORITHM:
          An algorithm which is a sequence of two or more component
            algorithms, as defined in {{sec-composite-structs}}.

DER:
          Distinguished Encoding Rules as defined in [X.690].

PUBLIC / PRIVATE KEY:
          The public and private portion of an asymmetric cryptographic
            key, making no assumptions about which algorithm.




# Composite Structures {#sec-composite-structs}
In order for public keys and private keys to be composed of multiple algorithms, we define encodings consisting of a sequence of public key or private key primitives (aka "components") such that these structures can be used as a drop-in replacement for existing public key fields such as those found in PKCS#10 [RFC2986], CMP [RFC4210], X.509 [RFC5280], CMS [RFC5652], and the Trust Anchor Format [RFC5914].

This section defines the following structures:

  - The id-alg-composite is an OID identifying a composite public key.

  - The CompositePublicKey carries all the public keys associated with an identity within a single public key structure.

  - The CompositePrivateKey carries all the private keys associated with an identity within a single private key structure.


## Algorithm Identifiers {#sec-alg-identifier}

The Composite-Key algorithm identifier is used for identifying a generic public key and a private key.

~~~ asn.1
id-composite-key OBJECT IDENTIFIER ::= {
  iso(1) identified-organization(3) dod(6) internet(1) private(4) 
  enterprise(1) OpenCA(18227) algorithms(2) id-pk-compositeCrypto(1) }
~~~

The Composite-Component-Key algorithm identifier is user for idententifying a component within an explicit public key.
~~~ asn.1
id-composite-component-key OBJECT IDENTIFIER ::= { TBD }
~~~

EDNOTE: these are a temporary OIDs for the purposes of prototyping. We are requesting IANA to assign a permanent OID, see {{sec-iana}}.


## Composite Keys

A composite key is a single key object that performs an atomic signature or verification operation, using its encapsulated sequence of component keys.

The ASN.1 algorithm object for composite public and private keys is:

~~~ ASN.1
pk-Composite PUBLIC-KEY ::= {
    KEY CompositePublicKey
    PARAMS ARE absent
    PRIVATE-KEY CompositePrivateKey
}
~~~
{: artwork-name="CompositeAlgorithmObject-asn.1-structures"}


### Key Usage

For protocols such as X.509 [RFC5280] that specify key usage along with the public key, any key usage may be used with Composite keys, with the requirement that the specified key usage MUST apply to all component keys. For example if a Composite key is marked with a KeyUsage of digitalSignature, then all component keys MUST be capable of producing digital signatures. id-alg-composite MUST NOT be used to implement mixed-usage keys, for example, where a digitalSignature and a keyEncipherment key are combined together into a single Composite key object.

### AND, OR, and K-of-N modes

Once an end entity has been issued multiple public keys, it is easy to imagine different modes and policies for using these keys. For example a logical AND would provide the strictest security by requiring any usage of a composite key to always use all component keys. Meanwhile, a logical OR would provide the greatest migration flexibility by allowing any component key to be used by itself. There can also be modes in between the two extremes such as a "K of N" mode, or a policy explicitely listing acceptable combinations of algorithms.

While these modes are an important part of composite signature and encryption algorithms, they do not affect the structure of the composite public and private keys, and are therefore outside the scope of this draft. If the community desires, future versions of this draft may define and X.509 extended key usage or v3 extension to convey this key usage policy information in an X.509 certificate.

## Composite Public Key {#sec-composite-pub-keys}

Composite public key data is represented by the following structure:

~~~ ASN.1
CompositePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo
~~~
{: artwork-name="CompositePublicKey-asn.1-structures"}


The corresponding AlgorithmIdentifier for a composite public key MUST use the id-alg-composite object identifier, defined in {{sec-alg-identifier}}, and the parameters field MUST be absent.

A composite public key MUST contain at least two component public keys.

A CompositePublicKey MUST NOT contain a component public key which itself describes a composite key; i.e. recursive CompositePublicKeys are not allowed.

EDNOTE: unclear that banning recursive composite keys actually accomplishes anything other than a general reduction in complexity and therefore reduction in attack surface. In particular, with the addition of Composite (AND mode) and Composite-OR (OR mode), recursion actually allows full boolean expression. Is this valuable?

Each element of a CompositePublicKey is a SubjectPublicKeyInfo object encoding a component public key. When the CompositePublicKey must be provided in octet string or bit string format, the data structure is encoded as specified in {{sec-encoding-rules}}.


### Generic Composite Public Key

In this mode the PUBLIC-KEY IDENTIFIER SHALL be id-composite-key. Each component SubjectPublicKeyInfo SHALL contain an AlgorithmIdentifier OID which identifies the public key type and params for the public key contained within it. See {{appdx-genComposite-examples}} for examples.

This mode provides a completely generic structure where key types can be combined into arbitrary combinations by runtime agents; ie no OIDs need to be assigned beyond id-composite-key and the OIDs for the individual component algorithms.

The motivation for this mode is primarily for prototyping work prior to the standardization of algorithm identifiers for explicit combinations of algorithms. However, the authors envision that this mode will remain relevant beyond full standardization for example in environments requiring very high levels of crypto agility, for example where clients support a large number of algorithms or where a large number of keys will be used at a time and it is therefore prohibitive to define algorithm identifiers for every combination of pairs, triples, quadtuples, etc of algorithms.

### Explicit Composite Public Key

In this mode, he PUBLIC-KEY IDENTIFIER SHALL be and OID which is registered to represent a specific combination of component public key types. Each component SubjectPublicKeyInfo SHALL contain an AlgorithmIdentifier OID of id-composite-component-key, which is only a placeholder to indicate that the type of key needs to be infered by the client from the top-level PUBLIC-KEY IDENTIFIER and the order of this key within the SEQUENCE. See {{appdx-expComposite-examples}} for examples. Also see {{appdx-creatingExplicitCombinations}} for guidance on creating and registering OIDs for specific explicit combinations.

This mode provides a rigid way of specifying supported combinations of algorithms.

The motivation for this mode is make it easier to reference and enforce specific combinations of algorithms. The authors envision this being useful for client-server negotiated protocols, protocol designers who wish to place constraints on allowable algorithm combinations in the protocol specification, as well as audited environments that wish to prove that only certain combinations will be supported by clients.


## Composite Private Key

The composite private key data is represented by the following structure:

~~~ ASN.1
CompositePrivateKey ::= SEQUENCE SIZE (2..MAX) OF OneAsymmetricKey
~~~
{: artwork-name="CompositePrivateKey-asn.1-structures"}

Each element is a OneAsymmetricKey [RFC5958] object for a component private key.

The corresponding AlgorithmIdentifier for a composite private key MUST use the id-alg-composite object identifier, and the parameters field MUST be absent.

A CompositePrivateKey MUST contain at least two component private keys, and they MUST be in the same order as in the corresponding CompositePublicKey.

EDNOTE: does this also need an explicit version?

## Encoding Rules {#sec-encoding-rules}
<!-- EDNOTE 7: Examples of how other specifications specify how a data structure is converted to a bit string can be found in RFC 2313, section 10.1.4, 3279 section 2.3.5, and RFC 4055, section 3.2. -->

Many protocol specifications will require that the composite public key and composite private key data structures be represented by an octet string or bit string.

When an octet string is required, the DER encoding of the composite data structure SHALL be used directly.

When a bit string is required, the octets of the DER encoded composite data structure SHALL be used as the bits of the bit string, with the most significant bit of the first octet becoming the first bit, and so on, ending with the least significant bit of the last octet becoming the last bit of the bit string.

In the interests of simplicity and avoiding compatibility issues, implementations that parse these structures MAY accept both BER and DER.



# In Practice {#sec-in-pract}

This section addresses practical issues of how this draft affects other protocols and standards.


EDNOTE 10: Possible topics to address:

  - The size of these certs and cert chains.
  - In particular, implications for (large) composite keys / signatures / certs on the handshake stages of TLS and IKEv2.
  - If a cert in the chain is a composite cert then does the whole chain need to be of composite Certs?
  - We could also explain that the root CA cert does not have to be of the same algorithms. The root cert SHOULD NOT be transferred in the authentication exchange to save transport overhead and thus it can be different than the intermediate and leaf certs.
  - We could talk about overhead (size and processing).
  - We could also discuss backwards compatibility.
  - We could include a subsection about implementation considerations.


## Textual encoding of Composite Private Keys

CompositePrivateKeys can be encoded to the Privacy-Enhanced Mail (PEM) [RFC1421] format by placing a CompositePrivateKey into the privateKey field of a PrivateKeyInfo or OneAsymmetricKey object, and then applying the PEM encoding rules as defined in [RFC7468] section 10 and 11 for plaintext and encrypted private keys, respectively.


## Asymmetric Key Packages (CMS)

The Cryptographic Message Syntax (CMS), as defined in [RFC5652], can be used to digitally sign, digest, authenticate, or encrypt the asymmetric key format content type.

When encoding composite private keys, the privateKeyAlgorithm in the OneAsymmetricKey SHALL be set to id-alg-composite.

The parameters of the privateKeyAlgorithm SHALL be a sequence of AlgorithmIdentifier objects, each of which are encoded according to the rules defined for each of the different keys in the composite private key.

The value of the privateKey field in the OneAsymmetricKey SHALL be set to the DER encoding of the SEQUENCE of private key values that make up the composite key. The number and order of elements in the sequence SHALL be the same as identified in the sequence of parameters in the privateKeyAlgorithm.

The value of the publicKey (if present) SHALL be set to the DER encoding of the corresponding CompositePublicKey. If this field is present, the number and order of component keys MUST be the same as identified in the sequence of parameters in the privateKeyAlgorithm.

The value of the attributes is encoded as usual.


<!-- End of In Practice section -->

# IANA Considerations {#sec-iana}
The ASN.1 module OID is TBD.  The id-composite-key and id-composite-or-key OIDs are to be assigned by IANA.  The authors suggest that IANA assign an OID on the id-pkix arc:

~~~ ASN.1
id-composite-key OBJECT IDENTIFIER ::= {
    iso(1) identified-organization(3) dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) algorithms(6) composite(??) }

id-composite-component-key OBJECT IDENTIFIER ::= { TBD }
~~~

<!-- End of IANA Considerations section -->


# Security Considerations

## Reuse of keys in a Composite public key {#sec-secCons-keyReuse}

There is an additional security consideration that some use cases such as signatures remain secure against downgrade attacks if and only if component keys are never used outside of their composite context and therefore it is RECOMMENDED that component keys in a composite key are uniquely generated. In particular, the components of a composite key SHOULD NOT also appear in single-key certificates. This is particularly relevant for protocols that use composite keys in a logical AND mode since the appearance of the same component keys in single-key contexts undermines the binding of the component keys into a single composite key.

## Policy for Deprecated and Acceptable Algorithms

Traditionally, a public key, certificate, or signature contains a single cryptographic algorithm. If and when an algorithm becomes deprecated (for example, RSA-512, or SHA1), it is obvious that structures using that algorithm are implicitly revoked.

In the composite model this is less obvious since a single public key, certificate, or signature may contain a mixture of deprecated and non-deprecated algorithms. Moreover, implementers may decide that certain cryptographic algorithms have complementary security properties and are acceptable in combination even though neither algorithm is acceptable by itself.

Specifying a modified verification process to handle these situations is beyond the scope of this draft, but could be desirable as the subject of an application profile document, or to be up to the discretion of implementers.

~~~
2. Check policy to see whether A1, A2, ..., An constitutes a valid
   combination of algorithms.

   if not checkPolicy(A1, A2, ..., An), then
     output "Invalid signature"
~~~

While intentionally not specified in this document, implementors should put careful thought into implementing a meaningful policy mechanism within the context of their signature verification engines, for example only algorithms that provide similar security levels should be combined together.

EDNOTE 11: Max is working on a CRL mechanism to accomplish this.

## Protection of Private Keys

Structures described in this document do not protect private keys in any way unless combined with a security protocol or encryption properties of the objects (if any) where the CompositePrivateKey is used (see next Section).

Protection of the private keys is vital to public key cryptography. The consequences of disclosure depend on the purpose of the private key. If a private key is used for signature, then the disclosure allows unauthorized signing. If a private key is used for key management, then disclosure allows unauthorized parties to access the managed keying material. The encryption algorithm used in the encryption process must be at least as 'strong' as the key it is protecting.

## Checking for Compromised Key Reuse

Certificate Authority (CA) implementations need to be careful when checking for compromised key reuse, for example as required by WebTrust regulations; when checking for compromised keys, you MUST unpack the CompositePublicKey structure and compare individual component keys. In other words, for the purposes of key reuse checks, the composite public key structures need to be un-packed so that primitive keys are being compared. For example if the composite key {RSA1, PQ1} is revoked for key compromise, then the keys RSA1 and PQ1 need to be indivitually considered revoked. If the composite key {RSA1, PQ2} is submitted for certification, it SHOULD be rejected because the key RSA1 was previously declared compromised even though the key PQ2 is unique.



<!-- End of Security Considerations section -->

# Appendices

## Creating explicit combinations {#appdx-creatingExplicitCombinations}

The following ASN.1 Information Objects may be useful in defining and parsing explicit pairs of public key types. Given an ASN.1 2002 compliant ASN.1 compiler, these Information Objects will enforce the binding between the public key types specified in the instantiation of pk-explicitComposite, and the wire objects which implement it. The one thing that is not enforced automatically by this Information Object is that publicKey.params are intended to be absent if and only if they are absent for the declared public key type. This ASN.1 module declares them OPTIONAL and leaves it to implementors to perform this check explicitely.

~~~ ASN.1
-- pk-explicitComposite - Composite public key information object

pk-explicitComposite{OBJECT IDENTIFIER:id, PUBLIC-KEY:firstPublicKey,
 FirstPublicKeyType, PUBLIC-KEY:secondPublicKey, SecondPublicKeyType} 
 PUBLIC-KEY ::= {
    IDENTIFIER id
    KEY ExplicitCompositePublicKey{firstPublicKey, FirstPublicKeyType,
     secondPublicKey, SecondPublicKeyType}
    PARAMS ARE absent
    CERT-KEY-USAGE {digitalSignature, nonRepudiation, keyCertSign,
      cRLSign}
}
~~~

The following ASN.1 object class then automatically generates the
public key structure from the types defined in pk-explicitComposite.

~~~ ASN.1
-- ExplicitCompositePublicKey - The data structure for a composite 
-- public key sec-alg-identifier and SecondPublicKeyType are needed
-- because PUBLIC-KEY contains a set of public key types, not a single
-- type.
-- TODO The parameters should be optional only if they are marked 
-- optional in the PUBLIC-KEY.


ExplicitCompositePublicKey{PUBLIC-KEY:firstPublicKey, FirstPublicKeyType, 
  PUBLIC-KEY:secondPublicKey, SecondPublicKeyType} ::= SEQUENCE {
    firstPublicKey SEQUENCE {
        params firstPublicKey.&Params OPTIONAL,
        publicKey FirstPublicKeyType
    },
    secondPublicKey SEQUENCE {
        params secondPublicKey.&Params OPTIONAL,
        publicKey SecondPublicKeyType
    }
}
~~~

Using this module, it becomes trivial to define explicit pairs. For an example, see {{appdx-expComposite-examples}}.

To define explicit triples, quadtuples, etc, these Information Objects can be extended to have thirdPublicKey, fourthPublicKey, etc throughout.


## ASN.1 Module

~~~ ASN.1

<CODE STARTS>

Composite-Keys-2022
  { TBD }

DEFINITIONS IMPLICIT TAGS ::= BEGIN

EXPORTS ALL;

IMPORTS
  PUBLIC-KEY, SIGNATURE-ALGORITHM
    FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-algorithmInformation-02(58) }

  SubjectPublicKeyInfo
    FROM PKIX1Explicit-2009
      { iso(1) identified-organization(3) dod(6) internet(1)
        security(5) mechanisms(5) pkix(7) id-mod(0)
        id-mod-pkix1-explicit-02(51) }

  OneAsymmetricKey
    FROM AsymmetricKeyPackageModuleV1
      { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
        pkcs-9(9) smime(16) modules(0)
        id-mod-asymmetricKeyPkgV1(50) } ;

--
-- Object Identifiers
--

-- To be replaced by IANA
id-composite-key OBJECT IDENTIFIER ::= {
  iso(1) identified-organization(3) dod(6) internet(1) private(4) 
  enterprise(1) OpenCA(18227) algorithms(2) id-pk-compositeCrypto(1) }

id-composite-component-key OBJECT IDENTIFIER ::= { TBD }

--
-- Public Key
--

pk-Composite PUBLIC-KEY ::= {
    IDENTIFIER id-composite-key
    KEY CompositePublicKey
    PARAMS ARE absent
    PRIVATE-KEY CompositePrivateKey
}

CompositePublicKey ::= SEQUENCE SIZE (2..MAX) OF SubjectPublicKeyInfo

CompositePrivateKey ::= SEQUENCE SIZE (2..MAX) OF OneAsymmetricKey


-- pk-explicitComposite - Composite public key information object

pk-explicitComposite{OBJECT IDENTIFIER:id, PUBLIC-KEY:firstPublicKey,
  FirstPublicKeyType, PUBLIC-KEY:secondPublicKey, SecondPublicKeyType} 
  PUBLIC-KEY ::= {
    IDENTIFIER id
    KEY ExplicitCompositePublicKey{firstPublicKey, FirstPublicKeyType,
      secondPublicKey, SecondPublicKeyType}
    PARAMS ARE absent
}

   The following ASN.1 object class then automatically generates the
   public key structure from the types defined in pk-explicitComposite.

-- ExplicitCompositePublicKey - The data structure for a composite 
-- public key sec-alg-identifier and SecondPublicKeyType are needed 
-- because PUBLIC-KEY contains a set of public key types, not a single
-- type.
-- TODO The parameters should be optional only if they are marked 
-- optional in the PUBLIC-KEY


ExplicitCompositePublicKey{PUBLIC-KEY:firstPublicKey, FirstPublicKeyType,
  PUBLIC-KEY:secondPublicKey, SecondPublicKeyType} ::= SEQUENCE {
    firstPublicKey SEQUENCE {
        params firstPublicKey.&Params OPTIONAL,
        publicKey FirstPublicKeyType
    },
    secondPublicKey SEQUENCE {
        params secondPublicKey.&Params OPTIONAL,
        publicKey SecondPublicKeyType
    }
}

END

<CODE ENDS>

~~~

## Examples

### Generic Composite Public Key Examples {#appdx-genComposite-examples}

This is an example generic composite public key

~~~
-----BEGIN PUBLIC KEY-----
MIIBmDAMBgorBgEEAYGOMwIBA4IBhgAwggGBMFkwEwYHKoZIzj0CAQYIKoZIzj0D
AQcDQgAELGrFpFFDsF3WazCa6npSX5ItleWicfFiDBkSumENPA0KSx+kntAIDxXl
TYMAcoMdEYSUJW3DyXhe42CVFiHXkzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBAL9UuDDAEd0iqPNt1fwKUGz2A99ErWBvURBE3PxWxiX+Tl482OZGVdY/
jIF4d8jPGEVaYo1Hi3QO3JVwctAIOTHSrseozh/dAzBDu23OLBVT61BaZANA6x12
E07yAl43zuRnvVUg2iFLKDuyMfzohY3yWi+bjyYFcMYW6Fmi3s0NLpa4MmhX1K5S
9KbmgBrxr2h0U7nlglBEs+HEnpTYItiVzcyyJVBiQ99h6Tc6ZVzV2JwTb0fwhAZL
89GLe8EFltLFr/bqIt0vm89HAaerMkFR3YwZn+vxSiunNpg9gXrLpksk2WpxIu7Z
er34NvFTeJj55foy5u5761WrT8yrolkCAwEAAQ==
-----END PUBLIC KEY-----
~~~

which decodes as:

~~~
algorithm: AlgorithmIdentifier{id-composite-key}

subjectPublicKey: CompositePublicKey {
    SubjectPublicKeyInfo {
      algorithm: AlgorithmIdentifier {
        algorithm: ecPublicKey
        parameters: prime256v1
        }
      subjectPublicKey: <ec key octet string>
      },
      SubjectPublicKeyInfo {
      algorithm: AlgorithmIdentifier {
        algorithm: rsaEncryption
        parameters: NULL
        }
      subjectPublicKey: <rsa key octet string>
      }
    }
~~~

The corresponding private key is:

~~~
-----BEGIN PRIVATE KEY-----
MIIFHgIBADAMBgorBgEEAYGOMwIBBIIFCTCCBQUwQQIBADATBgcqhkjOPQIBBggq
hkjOPQMBBwQnMCUCAQEEILIwxNkjkO+vcqxZrQWDvKrDcH7Johbi7wyHfttTDh8D
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC/VLgwwBHdIqjz
bdX8ClBs9gPfRK1gb1EQRNz8VsYl/k5ePNjmRlXWP4yBeHfIzxhFWmKNR4t0DtyV
cHLQCDkx0q7HqM4f3QMwQ7ttziwVU+tQWmQDQOsddhNO8gJeN87kZ71VINohSyg7
sjH86IWN8lovm48mBXDGFuhZot7NDS6WuDJoV9SuUvSm5oAa8a9odFO55YJQRLPh
xJ6U2CLYlc3MsiVQYkPfYek3OmVc1dicE29H8IQGS/PRi3vBBZbSxa/26iLdL5vP
RwGnqzJBUd2MGZ/r8UorpzaYPYF6y6ZLJNlqcSLu2Xq9+DbxU3iY+eX6Mubue+tV
q0/Mq6JZAgMBAAECggEAFMdxJ448gm0otyNHGZPPLz46pm1RfQcp4R/xdhBAfdDU
FwT5s2yRFu8Y5di8/ZiMNL//swNBoG2axDoNpg02lPQiGjn5hNleZsf8W40IGZrf
E/91HCtZPX5c03aSDkR2WjTwCYZDWllMucr9BdAE7SkUZVY6IjF2EXVcb5uyIcer
9mG62UWvrt2vLgJP6nwkMGM9eSaYcKZ/f2g1gYhbqUbdvWWRqsY5g6oBHGS9VpGh
jgjxujTVmaWHWXikR/RnD7xb+f8cyaZt9eRSqbL9kx6qVoK2LOAviBGLnZ0h4k8P
AF1OcDyQcrGgLKw4q0WItFBdW//Hyf3SBoMb+jeEJwKBgQDxYTdyuaUUe/mdGN3q
CWgVA9vx6d+7tV4ehca+kDeOfsqwXNPx5hWq295+g7rfl6L/xzy0vWj7TebWtmX8
2xjl325Rn9R5v8fFxUNj29jkaoB/l01+FQ0PWUj7nTiQ6I8MKZNFclwHM0sjdbdw
xSjBPF1OcO+15jDZdQzdPOd/GwKBgQDK63TfApwOiExtj2HzW6WZAdSdbtXdE3d0
uNpS+uckIHEkJ0rEWkeNRjb5v5IXbaeFj2vSwowAQnPJ5RHCIuIZID/yJ5Fu5Ef2
+VU5oBjmFhzBvgROmRqiXRMfjKlZHQnAJthHknlA8y1pq0IAsTQ7BuXxGcHzA6re
gOwMVGbXmwKBgQCaiSkctCoyMSUgJNl+isMuIShheuAYpwc492DEhERtYFOYEfZH
eo0ItHd//ApaOBTNONtuw41AxyEw+dnVxtfr494XOAKqZ9QYlDCO8COuKVlXVqDw
Rb30w67sGD4s2BctLDjzT0IIAhjq/OSSuEddX65FGB0AEf3YWw3/Xoy/XQKBgGQ0
T7tMw5mdjvhPZNRS/nyHXeH8eJm6YjP+kLmHcxrw9k4fJRm/ZzQJZ15/TnpJSP94
aotiTNZX+mvJtbJDnZlAxrMi/PtguXTpfT9+oq0EYGEAH4pcqr1g7u+We44o+8aq
qAT3/O6o51UWH/rNhvhbGLOtv4vs1LUZvvb7uulfAoGBANn5QBWoCs+ka70lGzq2
GQqVB0MB3IY12HKm8RhKCdHctDOO2fWJIrDBIqYxmFIBR/w8gt10gAYAzqG1/ofY
p96mWqbV0dgPVS1/MvNgi1Y17XnqRlpgxdvDxh8W51j+aSUUbw9tRtOouhRwmSxv
njZssvGOfmVc2W3hY4I+t1w0
-----END PRIVATE KEY-----
~~~

TODO: decode the priv key.

### Explitic Composite Public Key Examples {#appdx-expComposite-examples}

-- Modify the Generic example as if it had a registered pairwise OID

Assume that the following is a defined explicit pair:

~~~ asn.1
id-pk-example-ECandRSA OBJECT IDENTIFIER ::= { 1 2 3 4 }

pk-example-ECandRSA PUBLIC-KEY ::= pk-explicitComposite{
    id-pk-example-ECandRSA,
    ecPublicKey,
    pk-ec,
    rsaEncryption,
    pk-rsa,
}
~~~


Then the same key as above could be encoded as an explicit composite public key as:

~~~
TODO: PEM
  Can't actually encode this because we haven't listed an OID value for
  id-composite-component-key.
~~~

which decodes as:

~~~
algorithm: AlgorithmIdentifier{id-pk-example-ECandRSA}

subjectPublicKey: CompositePublicKey {
    SubjectPublicKeyInfo {
      algorithm: AlgorithmIdentifier {
        algorithm: id-composite-component-key
        parameters: prime256v1
        }
      subjectPublicKey: <ec key octet string>
      },
      SubjectPublicKeyInfo {
      algorithm: AlgorithmIdentifier {
        algorithm: id-composite-component-key
        parameters: NULL
        }
      subjectPublicKey: <rsa key octet string>
      }
    }
~~~

The private key is identical for generic and explicit and so does not need to be repeated.

ENDNOTE: should they be identical?

## Intellectual Property Considerations

The following IPR Disclosure relates to this draft:

https://datatracker.ietf.org/ipr/3588/



# Contributors and Acknowledgements
This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past year in pursuit of this document:

John Gray (Entrust),
Serge Mister (Entrust),
Scott Fluhrer (Cisco Systems),
Panos Kampanakis (Cisco Systems),
Daniel Van Geest (ISARA),
Tim Hollebeek (Digicert),
Klaus-Dieter Wirth (D-Trust), and
François Rousseau.

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

## Making contributions

Additional contributions to this draft are weclome. Please see the working copy of this draft at, as well as open issues at:

https://github.com/EntrustCorporation/draft-ounsworth-pq-composite-keys


<!-- End of Contributors section -->
